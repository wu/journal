* Plenv shebang
  :PROPERTIES:
  :ID:       CCE505BA-A7B7-4AFD-A053-F5154E6A3DE0
  :END:

[[https://github.com/tokuhirom/plenv][Plenv]] is a great tool.  It is the perl version of ruby's [[https://github.com/sstephenson/rbenv][rbenv]].

After playing around with plenv for a while, I was hooked, and started
switching over all my projects.  Then I started seeing some strange
output from some of my cron jobs.  I was seeing error messages like
this in my logs/email on OS X:

#+begin_src sh
  line 3: use: command not found
  line 5: print: command not found

#+end_src

I looked at it long enough to see that it was confusing, and then I
put it on the back burner for a while.  A little while later, I
started seeing a similar problem on Solaris.  So I decided it was time
to look a little deeper.

I realized pretty quickly that my perl script was being executed by
bash rather than by perl.  So the obvious work-around was the secret
sauce from the perlrun manpage (see below).  But that was clearly a
hack, and I couldn't resist digging deeper to see where things went
awry.

** exercise the bug
   :PROPERTIES:
   :ID:       740A54C1-C4FA-4F69-9065-0005CABFC498
   :END:

Exercising the bug is a little bit tricky.  When I execute a perl
script directly on the command line that has the plenv perl shim in
the shebang, it works fine.

#+begin_src sh
  # create and test the perl script
  echo "#\!$HOME/.plenv/shims/perl" > foo.pl
  echo 'print "testing 1 2 3\n";' >> foo.pl
  chmod a+x foo.pl
  ./foo.pl

  # output: testing 1 2 3

#+end_src

But when I call that same script from a shell script wrapper, it runs
into problems.  Note that the shell script must run the perl script
using the shebang to trigger the bug.

#+begin_src sh
  # create and run the shell script wrapper
  echo '#!/usr/bin/env bash' > foo.sh
  echo "./foo.pl" >> foo.sh
  chmod a+x foo.sh
  ./foo.sh

  # output: ./foo.pl: line 2: print: command not found

#+end_src

Interestingly the bug does not happen if the wrapper script is written in zsh:

#+begin_src sh
  # create and run the shell script wrapper
  echo '#!/usr/bin/env zsh' > foo.zsh
  echo "./foo.pl" >> foo.zsh
  chmod a+x foo.zsh
  ./foo.zsh

  # output: testing 1 2 3

#+end_src

** searching for a plenv bug
   :PROPERTIES:
   :ID:       BD5ADB8D-5081-48D7-8B7A-0B7B4E1C1CD9
   :END:

I started looking at the plenv scripts, hoping there might be an easy
fix.  The shebang in the perl script above points to plenv's perl
shim, which is actually a bash script.  The shim then runs this
command:

#+begin_src sh
  exec $HOME/.plenv/libexec/plenv exec perl foo.pl

#+end_src

The plenv script is also a bash script, which in turn runs:

#+begin_src sh
  exec $HOME/.plenv/libexec/plenv-exec perl foo.pl

#+end_src

And plenv-exec is also a bash script, which finally runs my script
with the appropriate version of the perl binary, like so:

#+begin_src sh
  exec -a perl $HOME/.plenv/versions/5.18.1/bin/perl foo.pl

#+end_src

Somewhere in the stack it was getting confusing and evaluating the
contents of foo.pl as if it were a bash script.

I started writing test cases to try and figure out exactly where
things were going wrong.  The results can be found [[https://gist.github.com/wu/8119651][here]]

I did some testing on multiple versions of a few operating systems,
and the issue affected OS X, FreeBSD, and Solaris--but not Linux.

I submitted a bug report for plenv [[https://github.com/tokuhirom/plenv/issues/63][here]], but I later closed the bug
since this appears to be more properly classified as an issue with
bash that affects plenv.

** perlrun
   :PROPERTIES:
   :ID:       307F8E65-B71F-4E98-8B48-CF25D91B4D39
   :END:

The [[http://perldoc.perl.org/perlrun.html][perlrun manpage]] contains a bit of magic that will run a perl
script with perl if it is being evaluated in a shell.

#+begin_src sh
  #!/bin/sh
  eval 'exec perl -x -wS $0 ${1+"$@"}'
      if 0;

#+end_src

And that does the trick:

#+begin_src sh
  echo "#\!$HOME/.plenv/shims/perl" > foo.pl
  echo "eval 'exec perl -x -wS \$0 \${1+\"\$@\"}'" >> foo.pl
  echo '    if 0;' >> foo.pl
  echo 'print "testing 1 2 3\n";' >> foo.pl
  chmod a+x foo.pl
  ./foo.pl
  # output: testing 1 2 3

  echo '#!/usr/bin/env bash' > foo.sh
  echo "./foo.pl" >> foo.sh
  chmod a+x foo.sh
  ./foo.sh
  # output: testing 1 2 3

#+end_src

** nested shebang
   :PROPERTIES:
   :ID:       0EDED161-2458-4C19-A6B3-1595A9A996A3
   :END:

I started searching and found a number of older references including
[[http://lists.netisland.net/archives/phlpm/phlpm-2000/msg00391.html][this one]] mentioning that bash does not support 'nested shebangs', i.e
a shebang that points at a script that itself begins with a shebang.
There is some great information [[http://www.in-ulm.de/~mascheck/various/shebang/#interpreter-script][here]].  I did not find any problems
with nested shebangs on recent versions of bash on any OS I tried.

#+begin_src sh
  # create the simplest possible bash shim
  echo '#!/usr/bin/env bash' > foo-shim.sh
  echo 'exec bash "$@"' >> foo-shim.sh
  chmod a+x foo-shim.sh

  # create a bash script that uses the shim
  echo "#\!$(pwd)/foo-shim.sh" > foo.sh
  echo 'echo "testing 1 2 3"' >> foo.sh
  chmod a+x foo.sh
  ./foo.sh

  # output: testing 1 2 3

#+end_src

** rbenv
   :PROPERTIES:
   :ID:       764A33B7-DB6E-44EA-8FA9-D04663D7DE58
   :END:

From my cursory comparison, it seems that the plenv bash scripts are
mostly rbenv with s/rbenv/plenv/g and s/ruby/perl/g.  So I was
assuming this bug would also affect rbenv.  And it appears that is true:

#+begin_src sh
  # create and test the ruby script
  echo '#!/opt/boxen/rbenv/shims/ruby' > foo.rb
  echo 'puts("testing 1 2 3")' >> foo.rb
  chmod a+x foo.rb
  ./foo.rb
  # output: testing 1 2 3

  # create the shell script wrapper
  echo '#!/usr/bin/env bash' > foo.sh
  echo "./foo.rb" >> foo.sh
  chmod a+x foo.sh
  ./foo.sh
  # output: ./foo.rb: line 2: syntax error near unexpected token `"testing 1 2 3"'
  # output: ./foo.rb: line 2: `puts("testing 1 2 3")'

#+end_src
